# -*- coding: utf-8 -*-
"""LHJAAAQ-Win-Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nkcBG-mF7WvQUydrUNOH034Zo4TTy_6v
"""

import tensorflow as tf
import numpy as np
import pandas as pd
from tensorflow import keras
from tensorflow.keras import layers
import requests
from io import StringIO

orig_url = "https://drive.google.com/file/d/1LLtEwWNGNWGIzr2NDP6sV39tp76U64vD/view?usp=sharing"
file_id = orig_url.split('/')[-2]
dwn_url = 'https://drive.google.com/uc?export=download&id=' + file_id
url = requests.get(dwn_url).text
csv_raw = StringIO(url)
dataframe = pd.read_csv(csv_raw)
print(dataframe)

dataframe.head()
dataframe.info()

# Commented out IPython magic to ensure Python compatibility.
val_dataframe = dataframe.sample(frac=0.2, random_state=1337)
train_dataframe = dataframe.drop(val_dataframe.index)

print(
    "Using %d samples for training and %d for validation"
#     % (len(train_dataframe), len(val_dataframe))
)

def dataframe_to_dataset(dataframe):
    dataframe = dataframe.copy()
    labels = dataframe.pop("Target")
    ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))
    ds = ds.shuffle(buffer_size=len(dataframe))
    return ds


train_ds = dataframe_to_dataset(train_dataframe)
val_ds = dataframe_to_dataset(val_dataframe)

for x, y in train_ds.take(1):
    print("Input:", x)
    print("Target:", y)

train_ds = train_ds.batch(10)
val_ds = val_ds.batch(10)

from tensorflow.keras.layers.experimental.preprocessing import Normalization
from tensorflow.keras.layers.experimental.preprocessing import CategoryEncoding
from tensorflow.keras.layers.experimental.preprocessing import StringLookup


def encode_numerical_feature(feature, name, dataset):
    # Create a Normalization layer for our feature
    normalizer = Normalization()

    # Prepare a Dataset that only yields our feature
    feature_ds = dataset.map(lambda x, y: x[name])
    feature_ds = feature_ds.map(lambda x: tf.expand_dims(x, -1))

    # Learn the statistics of the data
    normalizer.adapt(feature_ds)

    # Normalize the input feature
    encoded_feature = normalizer(feature)
    return encoded_feature


def encode_string_categorical_feature(feature, name, dataset):
    # Create a StringLookup layer which will turn strings into integer indices
    index = StringLookup()

    # Prepare a Dataset that only yields our feature
    feature_ds = dataset.map(lambda x, y: x[name])
    feature_ds = feature_ds.map(lambda x: tf.expand_dims(x, -1))

    # Learn the set of possible string values and assign them a fixed integer index
    index.adapt(feature_ds)

    # Turn the string input into integer indices
    encoded_feature = index(feature)

    # Create a CategoryEncoding for our integer indices
    encoder = CategoryEncoding(output_mode="binary")

    # Prepare a dataset of indices
    feature_ds = feature_ds.map(index)

    # Learn the space of possible indices
    encoder.adapt(feature_ds)

    # Apply one-hot encoding to our indices
    encoded_feature = encoder(encoded_feature)
    return encoded_feature


def encode_integer_categorical_feature(feature, name, dataset):
    # Create a CategoryEncoding for our integer indices
    encoder = CategoryEncoding(output_mode="binary")

    # Prepare a Dataset that only yields our feature
    feature_ds = dataset.map(lambda x, y: x[name])
    feature_ds = feature_ds.map(lambda x: tf.expand_dims(x, -1))

    # Learn the space of possible indices
    encoder.adapt(feature_ds)

    # Apply one-hot encoding to our indices
    encoded_feature = encoder(feature)
    return encoded_feature

# Categorical features encoded as integers
# GF = keras.Input(shape=(1,), name="GF", dtype="int64")
# GA = keras.Input(shape=(1,), name="GA", dtype="int64")

location = keras.Input(shape=(1,), name="Location", dtype="int64")
team = keras.Input(shape=(1,), name="Team", dtype="int64")

# Categorical feature encoded as string
# location = keras.Input(shape=(1,), name="Location", dtype="string")
# team = keras.Input(shape=(1,), name="Team", dtype="string")

# Numerical features
GF = keras.Input(shape=(1,), name="GF")
GA = keras.Input(shape=(1,), name="GA")
GFp = keras.Input(shape=(1,), name="GFp")
GAp = keras.Input(shape=(1,), name="GAp")
Shp = keras.Input(shape=(1,), name="Shp")
Svp = keras.Input(shape=(1,), name="Svp")
PPp = keras.Input(shape=(1,), name="PPp")
PKp = keras.Input(shape=(1,), name="PKp")

all_inputs = [
    location,
    team,
    GF,
    GA,
    GFp,
    GAp,
    Shp,
    Svp,
    PPp,
    PKp,
]

# Integer categorical features
# GF_encoded = encode_integer_categorical_feature(GF, "GF", train_ds)
# GA_encoded = encode_integer_categorical_feature(GA, "GA", train_ds)

# String categorical features
# location_encoded = encode_string_categorical_feature(location, "Location", train_ds)
# team_encoded = encode_string_categorical_feature(team, "Team", train_ds)

# Numerical features
location_encoded = encode_numerical_feature(location, "Location", train_ds)
team_encoded = encode_numerical_feature(team, "Team", train_ds)
GF_encoded = encode_numerical_feature(GF, "GF", train_ds)
GA_encoded = encode_numerical_feature(GA, "GA", train_ds)
GFp_encoded = encode_numerical_feature(GFp, "GF%", train_ds)
GAp_encoded = encode_numerical_feature(GAp, "GA%", train_ds)
Shp_encoded = encode_numerical_feature(Shp, "Sh%", train_ds)
Svp_encoded = encode_numerical_feature(Svp, "Sv%", train_ds)
PPp_encoded = encode_numerical_feature(PPp, "PP%", train_ds)
PKp_encoded = encode_numerical_feature(PKp, "PK%", train_ds)

print(Svp_encoded)

all_features = layers.concatenate(
    [
        location_encoded,
        team_encoded,
        GF_encoded,
        GA_encoded,
        GFp_encoded,
        GAp_encoded,
        Shp_encoded,
        Svp_encoded,
        PPp_encoded,
        PKp_encoded,
    ]
)
print(all_features.shape)
x = layers.Dense(32, activation="relu")(all_features)
x = layers.Dropout(0.5)(x)
output = layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(all_inputs, output)
model.compile("adam", "binary_crossentropy", metrics=["accuracy"])

# `rankdir='LR'` is to make the graph horizontal.
# keras.utils.plot_model(model, show_shapes=True, rankdir="LR")

# model.fit(train_ds, epochs=50, validation_data=val_ds)
model.fit(train_ds, epochs=150, validation_data=val_ds)

sample = {
    "Team": 10,
    "Location": 0,
    "GF": 158,
    "GA": 281,
    "GFp": 3.29,
    "GAp": 5.85,
    "Shp": 31.54,
    "Svp": 44.31,
    "PPp": 18.6,
    "PKp": 73.5,
}

input_dict = {name: tf.convert_to_tensor([value]) for name, value in sample.items()}
predictions = model.predict(input_dict)

print(
    "This teams has a %.1f percent probability "
    "of winning." % (100 * predictions[0][0],)
)